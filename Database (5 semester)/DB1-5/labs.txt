CREATE TABLE wallet (
	private_key VARCHAR(64) NOT NULL UNIQUE PRIMARY KEY,
	public_key VARCHAR(64) NOT NULL UNIQUE,
	wallet_currency VARCHAR(10) NOT NULL DEFAULT 'USD',
	email_address VARCHAR(40) NOT NULL,
	mobile_number VARCHAR(40) NOT NULL
);

CREATE TABLE client (
	id SERIAl NOT NULL UNIQUE PRIMARY KEY,
	balance NUMERIC(10, 3) DEFAULT 0,
	country VARCHAR(10) NOT NULL,
	transaction_date DATE NULL,
	transaction_time TIME NULL
);

CREATE TABLE block (
	block_header VARCHAR(64) NOT NULL UNIQUE PRIMARY KEY,
	prev_block VARCHAR(64) NOT NULL UNIQUE,
	block_size INT NOT NULL DEFAULT 1,
	transaction_counter INT NOT NULL
);

CREATE TABLE pool (
	id SERIAl NOT NULL UNIQUE PRIMARY KEY,
	name VARCHAR(40) NOT NULL,
	сurrency VARCHAR(10) NOT NULL DEFAULT 'BTC',
	status int DEFAULT 0,
	pay_per_share NUMERIC(10, 3) NOT NULL,
	pay_per_last_n_shares NUMERIC(10, 3) NOT NULL
);

CREATE TABLE miner (
	id SERIAL NOT NULL UNIQUE PRIMARY KEY,
	hashrate NUMERIC(10, 3) NOT NULL DEFAULT 0,
	profit NUMERIC(10, 3) NOT NULL DEFAULT 0,
	online_time INT NOT NULL
);

insert into workshop(name, found_year, id_director, description)
values('Crafty', 1500, 1, 'Best of all time');

create table rel_work_cust(
id_customer int references customer(id) not null,
id_workshop int references workshop(id) not null
);


create table if not exists workshop(
id serial not null primary key,
id_director int references director(id) not null,
found_year int,
found_year int,
description varchar(50)
);

name varchar(30),
alter table client
add check ( balance >= 0 );

alter table pool
add check ( status >= 0 and status <= 1);

alter table pool
add check ( pay_per_share > 0);

alter table pool
add check ( pay_per_last_n_shares > 0);

alter table miner
add check ( hashrate >= 0);

alter table miner
add check ( profit >= 0);

ALTER TABLE wallet ADD column client_id int;
ALTER TABLE wallet ADD
	CONSTRAINT FK_client_id FOREIGN KEY(client_id) REFERENCES client(id);

ALTER TABLE block ADD column client_id int;
ALTER TABLE block ADD
	CONSTRAINT FK_client_id FOREIGN KEY(client_id) REFERENCES client(id);

ALTER TABLE block ADD column pool_id int;
ALTER TABLE block ADD
	CONSTRAINT FK_pool_id FOREIGN KEY(pool_id) REFERENCES pool(id);

ALTER TABLE miner ADD column pool_id int;
ALTER TABLE miner ADD
	CONSTRAINT FK_pool_id FOREIGN KEY(pool_id) REFERENCES pool(id);

SELECT DISTINCT C1.City, C1.CompanyName FROM Customers C1 JOIN Customers AS C2 ON C2.City = C1.City WHERE C2.CustomerID <> C1.CustomerID AND C1.Country = 'Argentina' ORDER BY C1.City, C1.CompanyName 

1)Инструкция SELECT, использующая предикат сравнения. 

select name, hashrate
from pool
	join miner on miner.pool_id = pool.id
where hashrate > 10 and hashrate < 15;

2)Инструкция SELECT, использующая предикат BETWEEN. 

select id, transaction_time
from client
where transaction_date between '2018-05-10' and '2019-05-10';

3)Инструкция SELECT, использующая предикат LIKE. 

select public_key, email_address
from wallet
where email_address like '%.com';

4)Инструкция SELECT, использующая предикат IN с вложенным подзапросом. 

select id, balance
from client
	join wallet on wallet.client_id = client.id
where (balance in (select client.balance
						  from client
						  where balance > 10) and client.country = 'RU')

5)Инструкция SELECT, использующая предикат EXISTS с вложенным подзапросом. 

select id, country, balance
from client
	join wallet on wallet.client_id = client.id								
where exists (select client.country
						  from client
						  where country = 'RU');

select id, country, balance
from client
where exists (select wallet_currency
	from wallet
	where mobile_number like '7%');

6)Инструкция SELECT, использующая предикат сравнения с квантором

-- получить profit и id майнера, профит которого больше профита любого майнера с активным пулом
select id, profit
from miner
where profit > all (
	select status
	from pool
	where status = 1);

7)Инструкция SELECT, использующая агрегатные функции в выражениях столбцов. 

select sum(status) as "count active pool"
from pool

8)Инструкция SELECT, использующая скалярные подзапросы в выражениях столбцов. 

select name, 
(select max(pay_per_share)
 from pool
 where status = 1 )
 from pool;

9)Инструкция SELECT, использующая простое выражение CASE. 

select block_header,
	case (transaction_counter)
	when (
	select max(transaction_counter)
	from block)
	then 'max'
	
	when (
	select min(transaction_counter)
	from block)
	then 'min'
	
	else 'middle'
	
	end
 from block;

10)Инструкция SELECT, использующая поисковое выражение CASE. 

select id,
	case
		when balance < 1000 then 'poor'
		when balance < 2500 then 'middle'
		when balance < 5000 then 'rich'
		else 'very rich'
	end as "balance client"
 from client;

11)Создание новой временной локальной таблицы из результирующего набора данных инструкции SELECT. 

drop table Aver_balance;
select
    avg(balance) as aver_balance
into temporary
table Aver_balance
from 
    client;

select *
from Aver_balance;

12)Инструкция SELECT, использующая вложенные коррелированные подзапросы в качестве производных таблиц в предложении FROM. 


select client.id, client.country
from client join
    (   select client.balance
        from client
        where balance between 100 and 1000
        order by balance desc
 limit 1 )
 as low_balance on low_balance.balance = client.balance
 
union
 
select client.id, client.country
from client join
    (   select client.balance
        from client
        where balance between 1000 and 2500
        order by balance desc
 limit 1 )
 as middle_balance on middle_balance.balance = client.balance
 
union
 
select client.id, client.country
from client join
    (   select client.balance
        from client
        where balance between 2500 and 5000
        order by balance desc
 limit 1 )
 as middle_balance on middle_balance.balance = client.balance

13)Инструкция SELECT, использующая вложенные подзапросы с уровнем вложенности 3. 

select miner.id, miner.hashrate, miner.online_time
from miner join
(
	select hashrate
	from miner
	where hashrate / online_time <
	(
	select min(hashrate / online_time) 
		from (select hashrate, online_time
			  from miner 
			  where online_time > 50 and online_time < 300)
		as between_online_time
	)
	order by hashrate asc
) as total on total.hashrate = miner.hashrate

14)Инструкция SELECT, консолидирующая данные с помощью предложения GROUP BY, но без предложения HAVING. 

select name, sum(status) as working_process
from pool join miner on miner.id = pool.id
	where hashrate > 10
group by name
order by working_process desc

15)Инструкция SELECT, консолидирующая данные с помощью предложения GROUP BYи предложения HAVING. 

select name, sum(status) as working_process
from pool join miner on miner.id = pool.id
where hashrate > 10
group by name
having max(profit / online_time) > 100
order by working_process desc

16)Однострочная инструкция INSERT, выполняющая вставку в таблицу одной строки значений. 

delete from pool
where pool.name = 'EMCD';

insert into pool
    ( id, name, сurrency, status, pay_per_share, pay_per_last_n_shares)
values
    ( 10001, 'EMCD', 'BTC', 1, 99, 999);
select *
from pool
where pool.name = 'EMCD'

17)Многострочная инструкция INSERT, выполняющая вставку в таблицу результирующего набора данных вложенного подзапроса. 

delete from pool
where pool.name = 'F2Pool';

delete from pool
where pool.name = 'EMCD';

insert into pool
    ( id, name, сurrency, status, pay_per_share, pay_per_last_n_shares)
select
(
	select max(id) + 1
    from pool
), 'F2Pool', 'ETH', 1, 88, 888
from pool
limit 1

select *
from pool
order by pool.id desc

18)Простая инструкция UPDATE. 

update pool
set pay_per_share = pay_per_share * 1.1
where pay_per_last_n_shares < 500;

19)Инструкция UPDATE со скалярным подзапросом в предложении SET. 

update pool
set pay_per_share = ( 
	select min(pay_per_share)
	from pool)
where pool.id = 999;

20)Простая инструкция DELETE. 

delete from pool
where pool.name = 'F2Pool';

21)Инструкция DELETE с вложенным коррелированным подзапросом в предложении WHERE. 

insert into pool
    ( id, name, сurrency, status, pay_per_share, pay_per_last_n_shares)
values
    ( 10001, 'EMCD', 'BTC', 1, 99, 999);
select *
from pool
where pool.name = 'EMCD';

delete from pool
where id in
( 
select id
from pool
where name = 'EMCD'
);

22)Инструкция SELECT, использующая простое обобщенное табличное выражение 

with 
	CTE (country_client, count_balance)
	as
	(
		select country, count(balance) 
		from client
		group by country
	)
select cast(max(count_balance) as numeric (10, 3))
from CTE

23)Инструкция SELECT, использующая рекурсивное обобщенное табличное выражение. 

drop table Kings;
create table
if not exists Kings
(
    cur_king char
(40) not null primary key,
    prev_king char
(40)
);

insert into 
    Kings
    (cur_king, prev_king)
values
    (
        'Basil2',
		null
        
);

insert into 
    Kings
    (cur_king, prev_king)
values
    (
		'Ivan3',
        'Basil2'
);

insert into 
    Kings
    (cur_king, prev_king)
values
    (
		'Basil3',
        'Ivan3'
);

insert into 
    Kings
    (cur_king, prev_king)
values
    (	
		'Ivan4',
        'Basil3'
);

-- создание таблицы --
with recursive temp_str
( cur_king_t, prev_king_t)
as
    (
        select
        kg.cur_king, kg.prev_king
    from
        kings as kg
    where 
        prev_king is null
union all
    select
        kg.cur_king, kg.prev_king
    from
        kings as kg join temp_str as t_s on kg.prev_king = t_s.cur_king_t
)
select temp_str.cur_king_t, temp_str.prev_king_t
from temp_str;

24)Оконные функции. Использование конструкций MIN/MAX/AVG OVER() 

select client.id, client.transaction_date, client.transaction_time, wallet.wallet_currency,
cast(avg(balance) over(partition by country)  as numeric (10, 3)) as avg_balance,
min(balance) over(partition by country) as min_balance,
max(balance) over(partition by country) as max_balance
from client join wallet on wallet.client_id = client.id

25)Оконные функции для устранения дублей 
Придумать запрос, в результае которого в данных появляются полные дубли. Устранить дублирующиеся строки с использованием функции ROW_NUMBER() 

-- несколько транзакций в одно время
select client.id, wallet.wallet_currency, transaction_time,
row_number() over (partition by transaction_time) as rows,
cast(avg(balance) over(partition by country)  as numeric (10, 3)) as avg_balance,
min(balance) over(partition by country) as min_balance,
max(balance) over(partition by country) as max_balance
from client join wallet on wallet.client_id = client.id



—————————————————————————————————————————
Lab3

A. Четыре функции 

1)Скалярную функцию 
create function MaxPayPerShareActivePool() returns numeric(10,3) as
'
	select max(pay_per_share)
	from pool
	where status = 1
' language sql;

select MaxPayPerShareActivePool();

select *
from pool
order by pay_per_share desc;

drop function if exists MaxPayPerShareActivePool;

2)Подставляемую табличную функцию 
create or replace function getPools(int) returns setof pool as
'
	select *
	from pool
	where status = $1
' language sql;

select *
from getPools(0); 

3)Многооператорную табличную функцию 
create or replace function many3(NUMERIC(10, 3), NUMERIC(10, 3)) returns table
(
    t_id INT,
	t_name VARCHAR(40),
	t_pay_per_share NUMERIC(10, 3)
)
as
$$
	insert into pool(id, name, сurrency, status, pay_per_share, pay_per_last_n_shares)
	values(1001, 'ABC', 'BTC' , 1, 111.1,  222.2);

	update pool
	set status = 1
	where pay_per_share > 100;

	select pool.id, name, pay_per_share
	from pool join miner on miner.pool_id = pool.id
	where miner.online_time > $1 and miner.online_time < $2
$$ language sql;


select *
from many3(100, 300);

select *
    from miner;

delete from pool
where pool.id = 1001;

4)Рекурсивную функцию или функцию с рекурсивным ОТВ

drop table Kings;
create table
if not exists Kings
(
    cur_king char
(40) not null primary key,
    prev_king char
(40)
);

insert into
    Kings
    (cur_king, prev_king)
values
    (
        'Basil2',
		null

);

insert into
    Kings
    (cur_king, prev_king)
values
    (
		'Ivan3',
        'Basil2'
);

insert into
    Kings
    (cur_king, prev_king)
values
    (
		'Basil3',
        'Ivan3'
);

insert into
    Kings
    (cur_king, prev_king)
values
    (
		'Ivan4',
        'Basil3'
);

select * from Kings;

create or replace function rec_kings(varchar(30))
returns setof Kings
as
$$
    begin
        return query
        select (rec_kings(prev_king)).*
        from Kings
        where cur_king = $1;

        return query
        select *
        from Kings
        where cur_king = $1;
    end;
$$ language plpgsql;

select * from rec_kings('Ivan4')

---RETURN QUERY не выполняют возврат из функции. Они просто добавляют строки в результирующее множество.

B. Четыре хранимых процедуры 
1)Хранимую процедуру без параметров или с параметрами 
drop table if exists people_copy;

select *
into temp client_copy
from client;

create or replace procedure increaseBalance(incr numeric(10,3), startB numeric(10,3), stopB numeric(10,3)) as
'
	update client_copy
	set balance = balance + incr
	where balance between startB and stopB
' language sql;

call increaseBalance(100, 100, 500);

select client.balance as old_balance, client_copy.balance as new_balance
from client_copy join client on client.id = client_copy.id
where client.balance between 100 and 500
order by old_balance;

2)Рекурсивную хранимую процедуру или хранимую процедур с рекурсивным ОТВ 

drop table if exists people_copy;

select *
into temp client_copy
from client;

create or replace procedure updateBalance(newB numeric(10,3), startId int, stopId int) as
'
	begin
		if (startId <= stopId)
	then
		update client_copy
		set balance = newB
		where id = startId;
		call updateBalance(newB, startId + 1, stopId);
	end if;
	end;
' language plpgsql;

call updateBalance(666, 1, 10);

select client.balance as old_balance, client_copy.balance as new_balance
from client_copy join client on client.id = client_copy.id
where client.id between 1 and 10
order by old_balance;

3)Хранимую процедуру с курсором

drop table if exists client_copy;

select *
into temp client_copy
from client;

create or replace procedure updateBalanceCursor(koef numeric(10,3), startB numeric(10,3), stopB numeric(10, 3)) as
'
	declare cur cursor
		for select *
		from client
		where balance between startB and stopB;
		row record;
	begin
		open cur;
		loop
			fetch cur into row;
			exit when not found;
			update client_copy
			set balance = balance * koef
			where client_copy.id = row.id;
		end loop;
		close cur;
	end
' language plpgsql;

call updateBalanceCursor(1.5, 100, 500);

select client.balance as old_balance, client_copy.balance as new_balance
from client_copy join client on client.id = client_copy.id
where client.balance between 100 and 500
order by old_balance;

4)Хранимую процедуру доступа к метаданным 

create or replace procedure InfoTable() as
$$
declare 
	cur cursor
	for select name, type
	from (
		select table_name as name, table_type as type
		from information_schema.tables
		where table_schema = 'public'
	) AS tmp;
		 row record;
begin
	open cur;
	loop
		fetch cur into row;
		exit when not found;
		dd
	end loop;
	close cur;
end
$$ language plpgsql;

call InfoTable();

С Два DML триггера

1)Триггер AFTER 

drop table if exists catch_t;

create table if not exists catch_t
(
	catch_id SERIAl NOT NULL,
	catch_time time NOT NULL
);

create or replace function catch() returns trigger as
$$
	begin
		insert into catch_t(catch_id, catch_time) values (new.id, current_timestamp);
      	return new;
	end;
$$ language plpgsql;

create trigger triggerInsert
	after insert on client
	for each row
	execute procedure catch();

delete from client
where id = '1001';

select *
from client
order by id desc;

insert into client
values
(
	1001, 1111, 'RU', '2020-03-03', '22:22:22'
);

select *
from catch_t;

2)Триггер INSTEAD OF

drop view client_view;

create view client_view as
select *
from client;

create or replace function catchDelete() returns trigger as
$$
	begin
		update client
		set balance = 0,
		country = '-',
		transaction_time = '0:0:0',
		transaction_date = '1111-11-11'
		where id = old.id;
		return old;
	end;
$$ language plpgsql;

create trigger triggerDelete
	instead of delete on client_view
	for each row
	execute procedure catchDelete();

--- drop trigger triggerInsert on client;
--- drop function catch();


insert into client_view
values
(
	1001, 1111, 'RU', '2020-03-03', '22:22:22'
);

delete from client_view
where id = '1001';

select *
from client_view
where id = 1001;

---select *
---from client
---where id = 1001;

Защита - Процедура создает копии всех таблиц

create or replace procedure create_temp_table() as
$$
declare
	cur cursor
	for select table_name as name
	from information_schema.tables
	where table_schema = 'public';
	row record;
begin
	open cur;
	loop
	    fetch cur into row;
		exit when not found;
		EXECUTE 'drop table if exists temp_' || row.name || ';
		         create table temp_' || row.name || ' AS
                        select *
                        from '|| row.name || ';';
		raise notice '{name: %}', row.name;
	end loop;
	close cur;
end
$$ language plpgsql;

call create_temp_table();

select * from temp_wallet;
select * from temp_client;
select * from temp_block;
select * from temp_pool;
select * from temp_miner;

—————————————————————————————————————————
Lab4

Создать, развернуть и протестировать 6 объектов SQL CLR: 

1)  Определяемую пользователем скалярную функцию CLR,  
create extension plpython3u;
select * from pg_language;

create or replace function get_profit_by_id(id_f int) returns numeric(10, 3)
as
$$
    miners = plpy.execute("select * from miner")
    for m in miners:
        if m['id'] == id_f:
            return m['hashrate']
    return None
$$ language plpython3u;

select * from get_profit_by_id(10000);
select * from get_profit_by_id(100);


2)  Пользовательскую агрегатную функцию CLR,  
create extension plpython3u;
select * from pg_language;

create or replace function get_n_pay_per_share_by_status_currency(status_f int, currency_f varchar(10)) returns numeric(10, 3)
as
$$
    pools = plpy.execute("select * from pool")
    sum_pay_per_share = 0
    for p in pools:
        if p['status'] == status_f and p['сurrency'] == currency_f:
            sum_pay_per_share += p['pay_per_share']
    return sum_pay_per_share
$$ language plpython3u;

select * from get_n_pay_per_share_by_status_currency(1, 'EUR');
select * from get_n_pay_per_share_by_status_currency(0, 'EUR');


3)  Определяемую пользователем табличную функцию CLR,  
create extension plpython3u;
select * from pg_language;

create or replace function get_miner_by_online_time(online_time_f int) returns
table
(
    id int,
	hashrate numeric(10, 3),
	profit numeric(10, 3),
	online_time int
)
as
$$
    miners = plpy.execute("select * from miner")
    result_table = []
    for m in miners:
        if m['online_time'] > online_time_f:
            result_table.append(m)
    return result_table
$$ language plpython3u;

select * from get_miner_by_online_time(300);
select * from get_miner_by_online_time(400);


4)  Хранимую процедуру CLR,  
create extension plpython3u;
select * from pg_language;

create or replace procedure insert_miner(hashrate_f numeric(10, 3), profit_f numeric(10, 3), online_time_f int)
as
$$
    last_id = plpy.execute("select max(id) max_id from miner")
    last_id = last_id[0]["max_id"]
    last_id += 1
    miners = plpy.prepare("insert into miner(id, hashrate, profit, online_time) values($1, $2, $3, $4);", ["int", "numeric(10, 3)", "numeric(10, 3)", "int"]);
    plpy.execute(miners, [last_id, hashrate_f, profit_f, online_time_f])
$$ language plpython3u;

call insert_miner(11.1, 22.2, 111);

select * from miner
order by id desc;


5)  Триггер CLR,  
create extension plpython3u;
select * from pg_language;

drop table if exists catch_t_CLR;

create table if not exists catch_t_CLR
(
	catch_id int,
	catch_time varchar(40)
);

create or replace function catch_CLR() returns trigger as
$$
    catch_prepare = plpy.prepare("insert into catch_t_CLR(catch_id, catch_time) values($1, $2);", ["int", "time"])
    catch_insert = TD['new']
    now = plpy.execute("SELECT current_timestamp at time zone 'MSK'")[0]["timezone"]
    plpy.execute(catch_prepare, [catch_insert['id'], now])
$$ language plpython3u;

drop trigger triggerInsert_CLR on client;

create trigger triggerInsert_CLR
	after insert on client
	for each row
	execute procedure catch_CLR();

delete from client
where id = '1001';

SELECT current_timestamp at time zone 'MSK';

select *
from client
order by id desc;

insert into client
values
(
	1001, 1111, 'RU', '2020-03-03', '22:22:22'
);

select *
from catch_t_CLR;

6)  Определяемый пользователем тип данных CLR.  
create extension plpython3u;
select * from pg_language;

drop type client_characteristics;

create type client_characteristics as (
  id int,
  balance numeric(10, 3),
  country varchar(10)
);

create or replace function get_stats_by_id(id_f int) returns client_characteristics
as
$$
    cl_ch_prepare = plpy.prepare("select id, balance, country from client where id = $1", ["int"])
    cl_ch_execute = plpy.execute(cl_ch_prepare, [id_f])
    return (cl_ch_execute[0]['id'], cl_ch_execute[0]['balance'], cl_ch_execute[0]['country'])
$$ language plpython3u;

select * from get_stats_by_id(1000);
select * from client where id = 1000;


--- 2 на pl время ресурсы (Защита)

create or replace function get_n_pay_per_share_by_status_currency(status_f int, currency_f varchar(10)) returns numeric(10, 3)
as
$$
    pools = plpy.execute("select * from pool")
    sum_pay_per_share = 0
    for p in pools:
        if p['status'] == status_f and p['сurrency'] == currency_f:
            sum_pay_per_share += p['pay_per_share']
    return sum_pay_per_share
$$ language plpython3u;

select * from get_n_pay_per_share_by_status_currency(1, 'EUR');

create or replace function get_n_pay_per_share_by_status_currency_pl(status_f int, currency_f varchar(10)) returns numeric(10, 3)
as
$$
    select SUM(pay_per_share)
	from pool
	where status = status_f and сurrency = currency_f
$$ language sql;

drop function if exists get_n_pay_per_share_by_status_currency_pl;

select * from get_n_pay_per_share_by_status_currency_pl(1, 'EUR');


—————————————————————————————————————————
Lab5

1)Из таблиц базы данных, созданной в первой лабораторной работе, извлечь данные в XML (MSSQL) или JSON(Oracle, Postgres). Для выгрузки в XML проверить все режимы конструкции FOR XML  
select to_json(client) from client;

2)Выполнить загрузку и сохранение XML или JSON файла в таблицу. Созданная таблица после всех манипуляций должна соответствовать таблице базы данных, созданной в первой лабораторной работе.  
copy (select to_json(client) from client)
to '/Users/pc/Desktop/task2_lab5.json';

drop table temp_client;

create temp table temp_client(doc json);

copy temp_client from '/Users/pc/Desktop/task2_lab5.json';

select * from temp_client;

select p.*
from temp_client, json_populate_record(null::client, doc) as p; !!!!


3)Создать таблицу, в которой будет атрибут(-ы) с типом XML или JSON, или добавить атрибут с типом XML или JSON к уже существующей таблице. Заполнить атрибут правдоподобными данными с помощью команд INSERT или UPDATE.  
drop table copy_client;

CREATE TABLE copy_client (
  id serial NOT NULL,
  data jsonb
);

INSERT INTO copy_client VALUES (1, '{"balance":1726.330,"country":"MK","transaction_date":"2020-10-17","transaction_time":"19:22:00"}');
INSERT INTO copy_client VALUES (2, '{"balance":2101.161,"country":"ID","transaction_date":"2020-01-09","transaction_time":"17:53:00"}');
INSERT INTO copy_client VALUES (3, '{"balance":605.960,"country":"CA","transaction_date":"2017-09-12","transaction_time":"06:18:00"}');
INSERT INTO copy_client VALUES (4, '{"balance":4970.148,"country":"CA","transaction_date":"2017-10-08","transaction_time":"05:57:00"}');
INSERT INTO copy_client VALUES (5, '{"balance":702.965,"country":"PE","transaction_date":"2018-11-13","transaction_time":"09:05:00"}');

select * from copy_client;

update copy_client
set data = jsonb_set(data, '{"balance"}', '2222.222', true)
where id = 1;


4)Выполнить следующие действия: 

a)Извлечь XML/JSON фрагмент из XML/JSON документа 


copy (select json_agg(client) from client)
to '/Users/pc/Desktop/task2_lab5.json';

drop table temp_client;

create temp table temp_client(doc json);

copy temp_client from '/Users/pc/Desktop/task2_lab5.json';

select * from temp_client;

select p.*
from temp_client, json_array_elements(doc) p
limit 1;



b)Извлечь значения конкретных узлов или атрибутов XML/JSON  документа 

copy (select json_agg(client) from client)
to '/Users/pc/Desktop/task2_lab5.json';

drop table temp_client;

create temp table temp_client(doc json);

copy temp_client from '/Users/pc/Desktop/task2_lab5.json';

select * from temp_client;

select *
into temp temp_client1
from
(
    select p.*
    from temp_client, json_array_elements(doc) p
) fr;

select json_extract_path(temp_client1.value, 'balance')
from temp_client1;
 
c)Выполнить проверку существования узла или атрибута 

 copy (select json_agg(client) from client)
to '/Users/pc/Desktop/task2_lab5.json';

drop table temp_client;

create temp table temp_client(doc json);

copy temp_client from '/Users/pc/Desktop/task2_lab5.json';

select * from temp_client;

select *
into temp temp_client1
from
(
    select p.*
    from temp_client, json_array_elements(doc) p
) fr;

select json_extract_path(temp_client1.value, 'balance')
from temp_client1; не существует поля

select t.key, t.value
from temp_client1, json_each(temp_client1.value) t
where json_typeof(t.value) <> 'object'


d)Изменить XML/JSON документ 
 drop table copy_client;

CREATE TABLE copy_client (
  id serial NOT NULL,
  data jsonb
);

INSERT INTO copy_client VALUES (1, '{"balance":1726.330,"country":"MK","transaction_date":"2020-10-17","transaction_time":"19:22:00"}');
INSERT INTO copy_client VALUES (2, '{"balance":2101.161,"country":"ID","transaction_date":"2020-01-09","transaction_time":"17:53:00"}');
INSERT INTO copy_client VALUES (3, '{"balance":605.960,"country":"CA","transaction_date":"2017-09-12","transaction_time":"06:18:00"}');
INSERT INTO copy_client VALUES (4, '{"balance":4970.148,"country":"CA","transaction_date":"2017-10-08","transaction_time":"05:57:00"}');
INSERT INTO copy_client VALUES (5, '{"balance":702.965,"country":"PE","transaction_date":"2018-11-13","transaction_time":"09:05:00"}');

select * from copy_client;

update copy_client
set data = jsonb_set(data, '{"balance"}', '2222.222', true)
where id = 1;

e)Разделить XML/JSON документ на несколько строк по узлам  
CREATE TABLE copy_client (
  id serial NOT NULL,
  data json
);

INSERT INTO copy_client VALUES (1, '{"balance":1726.330,"country":"MK","transaction_date":"2020-10-17","transaction_time":"19:22:00"}');
INSERT INTO copy_client VALUES (2, '{"balance":2101.161,"country":"ID","transaction_date":"2020-01-09","transaction_time":"17:53:00"}');
INSERT INTO copy_client VALUES (3, '{"balance":605.960,"country":"CA","transaction_date":"2017-09-12","transaction_time":"06:18:00"}');
INSERT INTO copy_client VALUES (4, '{"balance":4970.148,"country":"CA","transaction_date":"2017-10-08","transaction_time":"05:57:00"}');
INSERT INTO copy_client VALUES (5, '{"balance":702.965,"country":"PE","transaction_date":"2018-11-13","transaction_time":"09:05:00"}');

drop table temp_client1;

copy (select json_agg(copy_client) from copy_client)
to '/Users/pc/Desktop/task4_lab5.json';

create temp table temp_client2(doc json);
copy temp_client2 from '/Users/pc/Desktop/task4_lab5.json';

select *
into temp temp_client1
from
(
    select p.*
    from temp_client2, json_array_elements(doc) p
) fr;

select * from temp_client2;

select json_each_text(temp_client1.value -> 'data') je
from temp_client1
order by je desc;

—————————————————————————————————————————
Lab6

import psycopg2
from contextlib import closing

#1 Выполнить скалярный запрос
def get_profit_by_id_python():
    id_f = int(input("Введите id = "))
    with closing(psycopg2.connect(dbname='temp_blockchain', user='postgres',
                        password='2468', host='localhost')) as conn:
        with conn.cursor() as cursor:
            try:
                cursor.execute("SELECT * FROM miner WHERE id = %(id)s", {'id': id_f })
                for row in cursor:
                    print(row, "\n")
            except:
                print('Невалидный запрос, попробуй еще раз!\n')

#2 Выполнить запрос с несколькими соединениями (JOIN)

def get_info_by_hasrate():
    hs_f = int(input("Введите hasrate = "))
    with closing(psycopg2.connect(dbname='temp_blockchain', user='postgres',
                        password='2468', host='localhost')) as conn:
        with conn.cursor() as cursor:
            try:
                cursor.execute("select * from pool pl join miner mr on mr.id = pl.id join block bl on pl.id = bl.pool_id where hashrate > %(hs)s", {'hs': hs_f})
                for row in cursor:
                    print(row, "\n")
            except:
                print('Невалидный запрос, попробуй еще раз!\n')

#3 Выполнить запрос с ОТВ(CTE) и оконными функциями

def get_OTB():
    with closing(psycopg2.connect(dbname='temp_blockchain', user='postgres',
                        password='2468', host='localhost')) as conn:
        with conn.cursor() as cursor:
            try:
                cursor.execute("with CTE (id_client, transaction_date_client, transaction_time_client, wallet_currency_wallet) as ( select client.id, client.transaction_date, client.transaction_time, wallet.wallet_currency, cast(avg(balance) over(partition by country)  as numeric (10, 3)) as avg_balance, min(balance) over(partition by country) as min_balance, max(balance) over(partition by country) as max_balance from client join wallet on wallet.client_id = client.id ) select * from CTE")
                for row in cursor:
                    print(row, "\n")
            except:
                print('Невалидный запрос, попробуй еще раз!\n')

#4 Выполнить запрос к метаданным

def get_info_meta():
    with closing(psycopg2.connect(dbname='temp_blockchain', user='postgres',
                        password='2468', host='localhost')) as conn:
        with conn.cursor() as cursor:
            try:
                cursor.execute("select table_name as name, table_type as type from information_schema.tables where table_schema = 'public'")
                for row in cursor:
                    print(row, "\n")
            except:
                print('Невалидный запрос, попробуй еще раз!\n')

#5 Вызвать скалярную функцию (написанную в третьей лабораторной работе)

def get_func_lab_3_1():

    with closing(psycopg2.connect(dbname='temp_blockchain', user='postgres',
                        password='2468', host='localhost')) as conn:
        with conn.cursor() as cursor:
            try:
                cursor.execute("select MaxPayPerShareActivePool()")
                for row in cursor:
                    print(row, "\n")
            except:
                print('Невалидный запрос, попробуй еще раз!\n')

#6 Вызвать многооператорную или табличную функцию (написанную в третьей лабораторной работе)

def get_func_lab_3_2():
    status_f = int(input("Введите status = "))
    with closing(psycopg2.connect(dbname='temp_blockchain', user='postgres',
                        password='2468', host='localhost')) as conn:
        with conn.cursor() as cursor:
            try:
                cursor.execute("select * from  getPools(%(status)s)", {'status': status_f })
                for row in cursor:
                    print(row, "\n")
            except:
                print('Невалидный запрос, попробуй еще раз!\n')

#7 Вызвать хранимую процедуру (написанную в третьей лабораторной работе)

def get_func_lab_3_3():
    inc_f = int(input("Введите inc = "))
    start_f = int(input("Введите start id = "))
    stop_f = int(input("Введите stop id = "))
    with closing(psycopg2.connect(dbname='temp_blockchain', user='postgres',
                        password='2468', host='localhost')) as conn:
        with conn.cursor() as cursor:
            try:
                cursor.execute("drop table if exists client_copy; select * into temp client_copy from client; call increaseBalance(%(inc)s, %(start)s, %(stop)s)", {'inc': inc_f, 'start': start_f, 'stop': stop_f})
            except:
                print('Невалидный запрос, попробуй еще раз!\n')

#8 Вызвать системную функцию или процедуру

def get_func_lab_3_4():
    with closing(psycopg2.connect(dbname='temp_blockchain', user='postgres',
                        password='2468', host='localhost')) as conn:
        with conn.cursor() as cursor:
            try:
                cursor.execute('SELECT current_database()')
                for row in cursor:
                    print(row, "\n")
            except:
                print('Невалидный запрос, попробуй еще раз!\n')

#9 Создать таблицу в базе данных, соответствующую тематике БД

def get_func_lab_3_5():
    with closing(psycopg2.connect(dbname='temp_blockchain', user='postgres',
                        password='2468', host='localhost')) as conn:
        with conn.cursor() as cursor:
            try:
                cursor.execute("drop table if exists identification; create table if not exists identification (id int PRIMARY KEY NOT NULL, type varchar(256) NOT NULL); ALTER TABLE identification ADD COLUMN id_client int; ALTER TABLE identification ADD CONSTRAINT FK_id_client FOREIGN KEY(id_client) REFERENCES client(id);")
                print("OK")
            except:
                print('Невалидный запрос, попробуй еще раз!\n')

# начальная(до 20тыс в месяц) продвинутая(дешевле вывод средств + до 40тыс в месяц) максимальная(до 40тыс в месяц)

#10 Выполнить вставку данных в созданную таблицу с использованием инструкции INSERT или COPY
def get_func_lab_3_6():
    with closing(psycopg2.connect(dbname='temp_blockchain', user='postgres',
                        password='2468', host='localhost')) as conn:
        with conn.cursor() as cursor:
            try:
                cursor.execute("insert into identification values (1, '3DS identification'),(2, 'ID identification'), (3, 'offline identification')")
            except:
                print('Невалидный запрос, попробуй еще раз!\n')

if __name__ == "__main__":
    flag_create = 0
    flag_insert = 0
    print(
        "Меню:\n"
        "1.Выбрать майнера по id\n"
        "2.Информация о цепи miner-pool-block по hashrate больше введенного значения\n"
        "3.Средний,минимальный и максимальный баланс клиента\n"
        "4.Вывести имя, тип таблицы\n"
        "5.Вывести максимальную оплату активных пулов\n"
        "6.Вывести pool по статусу\n"
        "7.Увеличить баланс\n"
        "8.Имя текущей базы данных\n"
        "9.Создать таблицу\n"
        "10.Вставка данных в созданную таблицу\n"
        "0.Выход\n")

    menu = int(input("Выберите действие: "))
    while (menu != 0):
        if (menu == 1):
            get_profit_by_id_python()
        elif (menu == 2):
            get_info_by_hasrate()
        elif (menu == 3):
            get_OTB()
        elif (menu == 4):
            get_info_meta()
        elif (menu == 5):
            get_func_lab_3_1()
        elif (menu == 6):
            get_func_lab_3_2()
        elif (menu == 7):
            get_func_lab_3_3()
        elif (menu == 8):
            get_func_lab_3_4()
        elif (menu == 9):
            if (flag_create == 0):
                get_func_lab_3_5()
                flag_create = 1
            else:
                print("Таблица уже создана\n")
        elif (menu == 10):
            if flag_create == 1 and flag_insert == 0:
                get_func_lab_3_6()
            elif flag_create == 0:
                print("Таблица не создана\n")
            else:
                print("Данные уже добавлены\n")

        print(
            "Меню:\n"
            "1.Выбрать майнера по id\n"
            "2.Информация о цепи miner-pool-block по hashrate больше введенного значения\n"
            "3.Средний,минимальный и максимальный баланс клиента\n"
            "4.Вывести имя, тип таблицы\n"
            "5.Вывести максимальную оплату активных пулов\n"
            "6.Вывести pool по статусу\n"
            "7.Увеличить баланс\n"
            "8.Имя текущей базы данных\n"
            "9.Создать таблицу\n"
            "10.Вставка данных в созданную таблицу\n"
            "0.Выход\n")

        menu = int(input("Выберите из списка: "))
 
___________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________



import psycopg2

def scalar_inquiry(cursor):
	type_contract = input("Введите тип договора: ")
	try:
		cursor.execute('SELECT AVG(ValueContract) as AvgValueContract FROM Contracts WHERE TypeContract = %(t)s',{"t": type_contract})
		for row in cursor:
			print(row, "\n")
	except:
		print('Что-то пошло не так, попробуй еще раз!\n')
	
def multi_join(cursor):
	number_contract = input("Введите номер договора: ")
	try:
		cursor.execute('select ct.numbercontract, p.accountnumber, cs.namecustomer from customers cs join contracts ct on cs.passportdetails = ct.customerpassport join pay p on ct.numbercontract = p.numbercontract where ct.numbercontract = %(n)s', {"n": number_contract})
		for row in cursor:
			print(row, "\n")
	except:
		print('Что-то пошло не так, попробуй еще раз!\n')
	
def cte(cursor):
	try:
		cursor.execute('WITH CTE (IdDirection, NameDirection, ValueContract) AS (SELECT D.IdDirection, D.NameDirection, CT.ValueContract FROM Contracts CT LEFT OUTER JOIN Directions D ON D.IdDirection = CT.IdDirection) SELECT AVG(ValueContract) OVER(PARTITION BY IdDirection, NameDirection) AS AvgPrice, MIN(ValueContract) OVER(PARTITION BY IdDirection, NameDirection) AS MinPrice, MAX(ValueContract) OVER(PARTITION BY IdDirection, NameDirection) AS MaxPrice from cte')
		for row in cursor:
			print(row, "\n")
	except:
		print('Что-то пошло не так, попробуй еще раз!\n')
def meta_inquiry(cursor):
	nametable = input("Введите название таблицы: ")
	try:
		cursor.execute('SELECT %(n)s as table, pg_size_pretty(pg_total_relation_size(%(n)s)) as size',{"n": nametable})
		for row in cursor:
			print(row, "\n")
	except:
		print('Что-то пошло не так, попробуй еще раз!\n')
def scalar_function(cursor):
	direction = input("Введите IdDirection: ")
	try:
		cursor.execute('select * from AvgValueDirection(%(d)s)', {"d": direction})
		for row in cursor:
			print(row, "\n")
	except:
		print('Что-то пошло не так, попробуй еще раз!\n')
def table_function(cursor):
	date_s = input("Введите начальную дата (example: 2020-01-01): ")
	date_e = input("Введите конечную дату (example: 2020-01-01): ")
	try:
		cursor.execute('select * from CheckDateContract(%(start)s, %(end)s)', {"start": date_s, "end": date_e})
		for row in cursor:
			print(row, "\n")
	except:
		print('Что-то пошло не так, попробуй еще раз!\n')
def storing_procedure(cursor):
	koef = input("Введите коэффициент: ")
	direction = input("Введите IdDirection: ")
	try:
		cursor.execute('drop table if exists contracts_copy')
		cursor.execute('select * into temp contracts_copy from contracts')
		cursor.execute('call update_valuecontract(%(k)s, %(d)s)',{"k": koef, "d": direction})
		cursor.execute('select Contracts.NumberContract, Contracts.IdDirection,Contracts.ValueContract as old_value, contracts_copy.ValueContract as new_value from contracts_copy join contracts on contracts_copy.NumberContract = contracts.NumberContract where Contracts.IdDirection = %(d)s',{"d": direction})
		for row in cursor:
			print(row, "\n")
	except:
		print('Что-то пошло не так, попробуй еще раз!\n')
		
def name_db(cursor):
	try:
		cursor.execute('SELECT current_database()')
		for row in cursor:
			print(row, "\n")
	except:
		print('Что-то пошло не так, попробуй еще раз!\n')
	
def create_table(cursor):
	try:
		cursor.execute("drop table if exists teachers;")
		cursor.execute("create table if not exists teachers (id int PRIMARY KEY NOT NULL, name varchar(256) NOT NULL);")
		cursor.execute("ALTER TABLE teachers ADD COLUMN IdExecutor int; ALTER TABLE teachers ADD CONSTRAINT FK_IdExecutor FOREIGN KEY(IdExecutor) REFERENCES executors(IdExecutor);")
		print("Таблица создана\n")
	except:
		print('Что-то пошло не так, попробуй еще раз!\n')
	return 1
def insert_in_table(cursor):
	try:
		cursor.execute("insert into teachers values (1, 'Коровин Петр',848421),(2, 'Klichko Mikhaail',852753);")
		cursor.execute("select * from teachers")
	except:
		print('Что-то пошло не так, попробуй еще раз!\n')
	return 1
if __name__ == "__main__":
	flag_create = 0
	flag_insert = 0
	flag_create, flag_insert = 0, 0
	conn = psycopg2.connect(dbname='universitydb', user='helen', 
		                password='159357', host='127.0.0.1', port = '5432')
	cursor = conn.cursor()
	print("MENU:\n1.Средняя стоимость обучения по типу договора\n2.Информация о договоре по номеру договора\n3.Средняя,минимальная и  максимальная стоимость обучения по всем направлениям\n4.Размер таблицы\n5.Средняя стоимость обучения по заданному направлению\n6.Вывести все договоры за определенный интервал\n7.Изменить стоимость обучения по определенному направлению\n8.Получить имя текущей базы данных\n9.Создать таблицу преподавателей\n10.Заполнить таблицу преподавателей\n0.Выход\n")
	
	menu = int(input("Выберите действие: "))
	while(menu != 0):
		if (menu == 1):
			scalar_inquiry(cursor)
			conn.commit()
		elif (menu == 2):
			multi_join(cursor)
			conn.commit()
		elif (menu == 3):
			cte(cursor)
			conn.commit()
		elif (menu == 4):
			meta_inquiry(cursor)
			conn.commit()
		elif (menu == 5):
			scalar_function(cursor)
			conn.commit()
		elif (menu == 6):
			table_function(cursor)
			conn.commit()
		elif (menu == 7):
			storing_procedure(cursor)
			conn.commit()
		elif (menu == 8):
			name_db(cursor)
			conn.commit()
		elif (menu == 9):
			if (flag_create == 0):
				flag_create = create_table(cursor)
				conn.commit()
			else:
				print("Таблица уже создана\n")
		elif (menu == 10):
			if flag_create == 1 and flag_insert == 0:
				flag_insert = insert_in_table(cursor)
				conn.commit()
			elif flag_create == 0:
				print("Таблица не создана\n")
			else:
				print("Данные уже добавлены\n")
			
		print("MENU:\n1.Средняя стоимость обучения по типу договора\n2.Информация о договоре по номеру договора\n3.Средняя,минимальная и  максимальная стоимость обучения по всем направлениям\n4.Размер таблицы\n5.Средняя стоимость обучения по заданному направлению\n6.Вывести все договоры за определенный интервал\n7.Изменить стоимость обучения по определенному направлению\n8.Получить имя текущей базы данных\n9.Создать таблицу преподавателей\n10.Заполнить таблицу преподавателей\n0.Выход\n")
		menu = int(input("Выберите действие: "))
		
	cursor.close()
	conn.close()


__________________________________________________________________________________________________________________________________________________________________________________



from peewee import *
import datetime
conn = PostgresqlDatabase(
    database='rk',
    user='helen',
    password='159357',
    host='127.0.0.1', 
    port="5432"
)

class BaseModel(Model):
    class Meta:
        database = conn 

class workers(BaseModel):
	id_w = IntegerField(column_name='id_w')
	FIO = CharField(column_name='FIO')
	birthday = DateField(column_name='birthday')
	department = CharField(column_name='department')
	class Meta:
        	table_name = 'workers'
class t_w(BaseModel):
	id_w = IntegerField(column_name='id_w')
	date_w = DateField(column_name='date_w')
	day_w = CharField(column_name='day_w')
	time_w = TimeField(column_name='time_w')
	type_w = IntegerField(column_name='type_w')
	class Meta:
        	table_name = 't_w'
   
def func_1():  
	first_t = t_w.alias()   
	subquery_1 = (first_t.select(first_t.id_w).where(first_t.type_w == 2, first_t.time_w >= '9:00',first_t.time_w <= '17:59').group_by(first_t.id_w).alias('sub_1'))
	subquery	
def func_2():
	print("\nЗапрос 2:")
	first_t = t_w.alias()
	
	subquery_1 = (first_t.select(first_t.id_w).where(first_t.type_w == 2, first_t.time_w >= '9:00',first_t.time_w <= '17:59').group_by(first_t.id_w).alias('sub_1'))
	
	now = datetime.datetime.now()
	
	query = workers.select(fn.AVG(now.year - workers.birthday.year)).join(subquery_1, on=(workers.id_w == subquery_1.c.id_w))
	
	result = query.dicts().execute()
	for i in result:
		print(i)
def func_3():
	print("\nЗапрос 3:")
	first_t = t_w.alias()
	
	subquery_1 = (first_t.select(first_t.id_w, fn.MIN(first_t.time_w).alias("first_time")).group_by(first_t.id_w, first_t.date_w).alias('sub_1'))
	
	query = workers.select(workers.department,fn.count((workers.id_w).distinct())).join(subquery_1, on=(workers.id_w == subquery_1.c.id_w)).where(subquery_1.c.first_time > '9:00').group_by(workers.department)
	
	result = query.dicts().execute()
	for i in result:
		print(i)
	

if __name__ == "__main__":
	func_1()
	
	#func_2()
	#func_3()

_________________________________________________________________________________________
__________________________________________________________________________________________________________________________________________________________________________________


--3
select w.department, count(distinct w.id_w)
from 
(
 select id_w, min(t_w.time_w) as first_time
 from t_w
 group by id_w, date_w
) as first_t
join workers w on first_t.id_w = w.id_w
where first_t.first_time > '9:00'
group by w.department

--2
select avg(date_part('year', age(current_date, birthday)))
from (
 select id_w
 from t_w
 where t_w.type_w = 2 and t_w.time_w between '9:00' and '17:59'
 group by id_w
) b
join workers w on b.id_w = w.id_w

insert into workers values (4,'Иванов Иван','27-09-1990','IBM'),
(5,'Сидоров Петр','13-11-1987','Бухгалтерия');

insert into t_w values
(4,'14-12-2018','Суббота','9:00',1),
(5,'14-12-2018','Суббота','9:00',1),
(4,'14-12-2018','Суббота','18:15',2),
(5,'14-12-2018','Суббота','18:25',2);

--1
select w.department
from 
(
 select first_t.id_w, count(*)
 from
 (
  select id_w, min(t_w.time_w) as first_time, date_w
  from t_w
  group by id_w, date_w
 )as first_t
where first_t.first_time > '9:00' and first_t.date_w between '16-12-2018' and '22-12-2018'
group by first_t.id_w
)d
join workers w on d.id_w = w.id_w
where count > 3


_________________________________________________________________________________________

_________________________________________________________________________________________


create or replace function CountLateComer(date_check date) returns bigint as
$$

 select count(*)
 from(
 select id_w 
 from t_w where date_w = date_check
 group by id_w 
 having min(time_w) > '9:00'
 ) d;
 
$$ language sql;


___________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Task1.sql

-- Задание 1 (8 баллов)
-- Создать базу данных и схему RK3. Создать в ней таблицы Преподаватели
create database rk;
\connect rk;

create schema rk3;

drop table if exists rk3.students;
drop table if exists rk3.teachers;

create table rk3.teachers (
	id           serial primary key,
	name         text,
	department   text,
	max_students smallint
);

create table rk3.students (
	id         serial primary key,
	name       text,
	birthday   date,
	department text,
	teacher_id int references rk3.teachers (id) null
);


-- Создать табличную функцию, подбирающу научного руководителя
-- не определившимся студентам, с учетом уже имеющейся занятости преподователя.
drop procedure if exists rk3.get_teachers_to_students();

create or replace procedure rk3.get_teachers_to_students() language plpgsql as $$
declare
	student record;
	teacher int;
begin
	for student in
		select *
		from rk3.students
		where teacher_id is null
	loop
		select rk3.teachers.id into teacher
		from rk3.teachers
			join rk3.students s on teachers.id = s.teacher_id
		group by teachers.id, max_students
		having count(s.id) < max_students
		limit 1;

		update rk3.students set teacher_id = teacher where id = student.id;
	end loop;
end
$$;

insert into rk3.teachers
	(name, department, max_students)
values
	('Рудаков Игорь Владимирович', 'ИУ7', 6),
	('Строганов Юрий Владимирович', 'ИУ7', 5),
	('Куров Андрей Владимирович', 'ИУ7', 6),
	('Скориков Татьяна Петровна', 'Л', 1);

insert into rk3.students
	(name, birthday, department, teacher_id)
values
	('Иванов Иван Иванович', '1990-09-25', 'ИУ', 1),
	('Петров Петр Петрович', '1987-11-12', 'Л', null),
	('Попов Поп Попович', '1998-01-02', 'ИУ', 3),
	('Попов Иван Иванович', '1998-01-03', 'РК', 2),
	('Иванов Петр Иванович', '1998-10-10', 'ИБМ', 1),
	('Иванов Иван Петрович', '1998-01-01', 'АК', null),
	('Керимов Иван Иванович', '1989-01-03', 'МТ', null),
	('Иванов Керим Иванович', '1988-01-10', 'МТ', null),
	('Иванов Иван Керимович', '1987-01-04', 'СК', 3),
	('Андреев Иван Иванович', '1986-04-01', 'Э', 1),
	('Иванов Андрей Иванович', '1985-03-01', 'Э', 1),
	('Иванов Иван Андреевич', '1984-02-01', 'Э', null);

call rk3.get_teachers_to_students();

select *
from rk3.students;
select rk3.teachers.id, (
	select count(*)
	from rk3.students
	where teacher_id = rk3.teachers.id
)
from rk3.teachers;

___________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

TASK2.PY

import psycopg2
from py_linq import Enumerable
from psycopg2.extras import DictConnection, DictCursor


connect = psycopg2.connect(
    dbname="postgres",
    user="user",
    password="",
    host="localhost",
    connection_factory=DictConnection,
    cursor_factory=DictCursor
)


def query1_1():
    query = "select department " \
            "from (" \
            "   select department, count(id) as c " \
            "   from rk3.students " \
            "   where teacher_id is null " \
            "   group by department " \
            ") as dc " \
            "order by c desc " \
            "limit 1"

    cursor = connect.cursor(cursor_factory=DictCursor)
    cursor.execute(query)
    result = cursor.fetchall()
    cursor.close()

    return result


def query1_2():
    cursor = connect.cursor(cursor_factory=DictCursor)
    cursor.execute("select * from rk3.students")

    filtered = Enumerable(cursor.fetchall()) \
        .where(lambda s: s["teacher_id"] is None).to_list()

    departments_freq = {}
    for student in filtered:
        if student["department"] in departments_freq:
            departments_freq[student["department"]] += 1
        else:
            departments_freq[student["department"]] = 1

    return departments_freq.items().sort(key=lambda x: x[1])[-1] if departments_freq.items() else []


def query2_1():
    query = "select rk3.students.* " \
            "from rk3.students " \
            "join rk3.teachers on teacher_id = teachers.id " \
            "where teachers.name = 'Рудаков Игорь Владимирович' " \
            "and extract(year from birthday) = 1990"

    cursor = connect.cursor(cursor_factory=DictCursor)
    cursor.execute(query)
    result = cursor.fetchall()
    cursor.close()

    return result


def query2_2():
    query = "select * from rk3.students"
    cursor = connect.cursor(cursor_factory=DictCursor)
    cursor.execute(query)
    students = cursor.fetchall()

    query = "select * from rk3.teachers"
    cursor.execute(query)
    teachers = cursor.fetchall()
    cursor.close()

    return Enumerable(students) \
        .join(Enumerable(teachers),
              lambda s: s['teacher_id'],
              lambda t: t['id'],
              lambda r: r) \
        .where(lambda r: r[1]['name'] == 'Рудаков Игорь Владимирович') \
        .where(lambda r: r[0]['birthday'].year == 1990) \
        .select(lambda r: r[0])


def query3_1():
    query = "select rk3.teachers.* " \
            "from rk3.teachers " \
            "where department = 'Л' and max_students = (" \
            "   select count(*)" \
            "   from students" \
            "   where teacher_id = rk3.teachers.id" \
            ")"

    cursor = connect.cursor(cursor_factory=DictCursor)
    cursor.execute(query)
    result = cursor.fetchall()
    cursor.close()

    return result


def query3_2():
    def count_students(studs, tid):
        return Enumerable(studs).where(lambda s: s['teacher_id'] == tid).count()

    query = "select * from rk3.students"
    cursor = connect.cursor(cursor_factory=DictCursor)
    cursor.execute(query)
    students = cursor.fetchall()

    query = "select * from rk3.teachers"
    cursor.execute(query)
    teachers = cursor.fetchall()
    cursor.close()

    return Enumerable(teachers) \
        .where(lambda t: t['department'] == 'Л') \
        .where(lambda t: t['max_students'] == count_students(students, t['id'])) \
        .to_list()


def main():
    print(query1_1())
    print(query1_2())
    print(query2_1())
    print(query2_2())
    print(query3_1())
    print(query3_2())


if __name__ == "__main__":
    main()
___________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________


drop function lateIT; 
create or replace function lateIT(latetm time) returns integer 
as 
$$ 
select count(distinct id)
 from employee join record on employee.id = record.id_employee 
where record.rtime > latetm and record.rtype = 1
$$ language sql;

select * from lateIT('9:00'); 
select * from employee join record on employee.id = record.id_employee

__________________________________________________________________________________________________________________________________________________________________________________


select client.id, client.country
from client join
    (   select email_address, client_id
        from wallet join client on wallet.client_id = client.id
        where email_address like '%.com'
	) as comEmail on comEmail.client_id = client.id;

__________________________________________________________________________________________________________________________________________________________________________________

--- вариант 2 Савинов Егор ИУ7-54Б

drop table typesOfSweet;
drop table suppliers;
drop table store;

create table typesOfSweet
(
	id SERIAL NOT NULL UNIQUE PRIMARY KEY,
	name VARCHAR(30) NOT NULL,
	composition VARCHAR(30) NOT NULL,
	description VARCHAR(200) NOT NULL
)

insert into typesOfSweet(id, name, composition, description)
values(1, 'nametypesOfSweet1', 'norm sostav1', 'good description1');

insert into typesOfSweet(id, name, composition, description)
values(2, 'nametypesOfSweet2', 'norm sostav2', 'good description2');

insert into typesOfSweet(id, name, composition, description)
values(3, 'nametypesOfSweet3', 'norm sostav3', 'good description3');

insert into typesOfSweet(id, name, composition, description)
values(4, 'nametypesOfSweet4', 'norm sostav4', 'good description4');

insert into typesOfSweet(id, name, composition, description)
values(5, 'nametypesOfSweet5', 'norm sostav5', 'good description5');

insert into typesOfSweet(id, name, composition, description)
values(6, 'nametypesOfSweet5', 'norm sostav6', 'good description6');

insert into typesOfSweet(id, name, composition, description)
values(7, 'nametypesOfSweet7', 'norm sostav7', 'good description7');

insert into typesOfSweet(id, name, composition, description)
values(8, 'nametypesOfSweet8', 'norm sostav8', 'good description8');

insert into typesOfSweet(id, name, composition, description)
values(9, 'nametypesOfSweet9', 'norm sostav9', 'good description9');

insert into typesOfSweet(id, name, composition, description)
values(10, 'nametypesOfSweet10','norm sostav10', 'good description10');

create table suppliers
(
	id SERIAL NOT NULL UNIQUE PRIMARY KEY,
	name VARCHAR(30) NOT NULL,
	INN int NOT NULL,
	address VARCHAR(200) NOT NULL
)
1
insert into suppliers(id, name, INN, address)
values(1, 'namesuppliers1', 1000, 'address suppliers1');

insert into suppliers(id, name, INN, address)
values(2, 'namesuppliers1', 1000, 'address suppliers1');
insert into suppliers(id, name, INN, address)
values(3, 'namesuppliers1', 1000, 'address suppliers1');
insert into suppliers(id, name, INN, address)
values(4, 'namesuppliers1', 1000, 'address suppliers1');
insert into suppliers(id, name, INN, address)
values(5, 'namesuppliers1', 1000, 'address suppliers1');
insert into suppliers(id, name, INN, address)
values(6, 'namesuppliers1', 1000, 'address suppliers1');
insert into suppliers(id, name, INN, address)
values(7, 'namesuppliers1', 1000, 'address suppliers1');
insert into suppliers(id, name, INN, address)
values(8, 'namesuppliers1', 1000, 'address suppliers1');
insert into suppliers(id, name, INN, address)
values(9, 'namesuppliers1', 1000, 'address suppliers1');
insert into suppliers(id, name, INN, address)
values(10, 'namesuppliers1', 1000, 'address suppliers1');

create table store
(
	id SERIAL NOT NULL UNIQUE PRIMARY KEY,
	name VARCHAR(30) NOT NULL,
	address VARCHAR(200) NOT NULL,
	registration_date date NOT NULL,
	rating int NOT NULL
)

insert into store(id, name, address, registration_date, rating)
values(1, 'namestore1', 'address store1', '2000-10-1', 1);

insert into store(id, name, address, registration_date, rating)
values(2, 'namestore1', 'address store1', '2000-10-1', 1);
insert into store(id, name, address, registration_date, rating)
values(3, 'namestore1', 'address store1', '2000-10-1', 1);
insert into store(id, name, address, registration_date, rating)
values(4, 'namestore1', 'address store1', '2000-10-1', 1);
insert into store(id, name, address, registration_date, rating)
values(5, 'namestore1', 'address store1', '2000-10-1', 1);
insert into store(id, name, address, registration_date, rating)
values(6, 'namestore1', 'address store1', '2000-10-1', 1);
insert into store(id, name, address, registration_date, rating)
values(7, 'namestore1', 'address store1', '2000-10-1', 1);
insert into store(id, name, address, registration_date, rating)
values(8, 'namestore1', 'address store1', '2000-10-1', 1);
insert into store(id, name, address, registration_date, rating)
values(9, 'namestore1', 'address store1', '2000-10-1', 1);
insert into store(id, name, address, registration_date, rating)
values(10, 'namestore1', 'address store1', '2000-10-1', 1);

drop table store_typesOfSweet;
drop table store_suppliers;
drop table typesOfSweet_suppliers;

create table store_typesOfSweet
(
	id_typesOfSweet int references typesOfSweet(id) NOT NULL,
	id_store int references store(id) NOT NULL
);

create table store_suppliers
(
	id_suppliers int references suppliers(id) NOT NULL,
	id_store int references store(id) NOT NULL
);

create table typesOfSweet_suppliers
(
	id_suppliers int references suppliers(id) NOT NULL,
	id_typesOfSweet int references typesOfSweet(id) NOT NULL
);

---21
select *
from store
where rating > 10;

---22
select *
cast(avg(rating) over (partition by address) as numeric(10,3)) as avg_rating,
min(rating) over (partition by address) as min_rating,
max(rating) over (partition by address) as max_rating
from store 


---23
select *
from store join
(
	select store.rating
	from store join 
)



__________________________________________________________________________________________________________________________________________________________________________________





create table if not exists office (
	id serial not null primary key,
	name varchar(30) not null,
	tel varchar(30),
	name_big varchar(30)
);

create table if not exists worker (
	id serial not null primary key references office(заведующий) not null,
	otdel varchar(30) references office(id) not null,
	doljnost varchar(30) not null,
	FIO varchar(30),
	price varchar(30),
);

create table if not exists medicine (
	id serial not null primary key,
	name varchar(30) not null,
	instruction varchar(30) not null,
	price varchar(30)
);

__________________________________________________________________________________________________________________________________________________________________________________

--- оставить людей с заданным балансом в выбранной стране и в выбранном промежутке времени
drop view client_view;

create view client_view as
select *
from client;

create or replace function MaxBalanceCoutry(numeric(10,3), varchar(5), date, date) returns table
(
	select_id int,
	select_balance NUMERIC(10, 3)
) as 
$$
	declare rec record;
	begin
		for rec in
		(
			select id, balance
			from client
			where balance > $1 and country = $2
		)
		loop
			select_id = rec.id;
			select_balance = rec.balance;
			delete from client_view
			where transaction_date between $3 and $4;
			return next;
		end loop;
	end;
$$ language plpgsql;

select *
from MaxBalanceCoutry(1, 'RU', '2000-02-02', '2020-02-02') join client_view
on client_view.id = select_id;

select * 
from client_view;

__________________________________________________________________________________________________________________________________________________________________________________

create table Employee
(
	EmployeeId serial,
	EmployeeName varchar(500),
	EmployeeSurname varchar(500),
	EmployeeРatronymic varchar(500),
	EmployeeAddress varchar(500),
	EmployeeInn int,
	EmployeeSex varchar(500),
	EmployeeDob date,
	EmployeeSeriesPasport int,
	EmployeeNumberPasport int,
	EmployeePosition varchar(500)
)

insert into Employee (EmployeeName,EmployeeSurname,EmployeeРatronymic, EmployeeAddress,EmployeeInn,EmployeeSex,EmployeeDob,EmployeeSeriesPasport,EmployeeNumberPasport,EmployeePosition)
values               ('Bob','agag','Dmitrievch', 'Moscow','123','M','2021-6-21','456','789','Boss');

select * from Employee

DELETE FROM Employee
WHERE EmployeeId=3;

drop table Employee
drop table Object
drop table LegalEntity
create table Room
(
	RoomId serial,
	RoomFloor int,
	RoomNumber int
)

insert into Room (RoomFloor,RoomNumber)
values               ('12', '1');

create table LegalEntity
(
	LegalEntityId serial,
	LegalEntityName varchar(500),
	LegalEntitySurname varchar(500),
	LegalEntityРatronymic varchar(500),
	LegalEntityAddress varchar(500),
	LegalEntityInn int,
	LegalEntitySex varchar(500),
	LegalEntityDob date,
	LegalEntitySeriesPasport int,
	LegalEntityNumberPasport int
)

insert into LegalEntity (LegalEntityName,LegalEntitySurname,LegalEntityРatronymic,LegalEntityAddress,LegalEntityInn,LegalEntitySex,LegalEntityDob,LegalEntitySeriesPasport,LegalEntityNumberPasport)
values               ('Bob','agag','Dmitrievch', 'Moscow','123','M','2021-6-21','456','789');

select * from LegalEntity

create table Object
(
	ObjectId serial,
	ObjectName varchar(500),
	ObjectDesc varchar(500),
	ObjectCondition varchar(500),
	ObjectPurchaseDate date,
	ObjectAvailable varchar(500),
	ObjectIdEmployee int,
	ObjectIdRoom int
)

insert into Object (
	ObjectName,
	ObjectDesc,
	ObjectCondition,
	ObjectPurchaseDate,
	ObjectAvailable,
	ObjectIdEmployee,
	ObjectIdRoom)
values               ('Bob', 'SMTH','Новое','2021-6-21','Да','123','456');




——————————————————————————————————————
create or replace function inc_legalentity_number() returns trigger as
$$
	begin
		update coursework_legalentity
		set employee_number = employee_number + 1
		where coursework_legalentity.id = new.legalentity_id;
		return NULL;
	end;
$$ language plpgsql;

create trigger triggerUpdateInc
	after insert on coursework_employee
	for each row
	execute procedure inc_legalentity_number();

create or replace function dec_legalentity_number() returns trigger as
$$
	begin
		update coursework_legalentity
		set employee_number = employee_number - 1
		where coursework_legalentity.id = old.legalentity_id;
		return NULL;
	end;
$$ language plpgsql;

create trigger triggerUpdateDec
	after DELETE ON coursework_employee
	for each row
	execute procedure dec_legalentity_number();


——————————————————————————————————————
	create or replace function inc_legalentity_number() returns trigger as
	$$
	begin
	update coursework_legalentity
	set employee_number = employee_number + 1
	where coursework_legalentity.id = new.legalentity_id;
	return NULL;
	end;
	$$ language plpgsql;
	
	create trigger triggerUpdateInc
	after insert on coursework_employee
	for each row
	execute procedure inc_legalentity_number();
	
	create or replace function dec_legalentity_number() returns trigger as
	$$
	begin
	update coursework_legalentity
	set employee_number = employee_number - 1
	where coursework_legalentity.id = old.legalentity_id;
	return NULL;
	end;
	$$ language plpgsql;
	
	create trigger triggerUpdateDec
	after DELETE ON coursework_employee
	for each row
	execute procedure dec_legalentity_number();
	\end{lstlisting}

——————————————————————————————————————